import _ from './ENV/Lodash.mjs'
import $Storage from './ENV/$Storage.mjs'
import ENV from "./ENV/ENV.mjs";
import URL from "./URL/URL.mjs";
import XML from "./XML/XML.mjs";
import VTT from "./WebVTT/WebVTT.mjs";

import Database from "./database/index.mjs";
import setENV from "./function/setENV.mjs";
import detectFormat from "./function/detectFormat.mjs";
import detectPlatform from "./function/detectPlatform.mjs";
import setCache from "./function/setCache.mjs";
import constructSubtitlesQueue from "./function/constructSubtitlesQueue.mjs";
import Composite from "./class/Composite.mjs";

const $ = new ENV("ğŸ¿ï¸ DualSubs: ğŸ¦ Universal v1.0.0(1003) Composite.Subtitles.response");

/***************** Processing *****************/
// è§£æ„URL
const url = new URL($request.url);
$.log(`âš  url: ${url.toJSON()}`, "");
// è·å–è¿æ¥å‚æ•°
const METHOD = $request.method, HOST = url.hostname, PATH = url.pathname, PATHs = url.pathname.split("/").filter(Boolean);
$.log(`âš  METHOD: ${METHOD}, HOST: ${HOST}, PATH: ${PATH}` , "");
// è§£ææ ¼å¼
let FORMAT = ($response.headers?.["Content-Type"] ?? $response.headers?.["content-type"])?.split(";")?.[0];
if (FORMAT === "application/octet-stream" || FORMAT === "text/plain") FORMAT = detectFormat(url, $response?.body, FORMAT);
$.log(`âš  FORMAT: ${FORMAT}`, "");
(async () => {
	// è·å–å¹³å°
	const PLATFORM = detectPlatform($request.url);
	$.log(`âš  PLATFORM: ${PLATFORM}`, "");
	// è¯»å–è®¾ç½®
	const { Settings, Caches, Configs } = setENV("DualSubs", [(["YouTube", "Netflix", "BiliBili", "Spotify"].includes(PLATFORM)) ? PLATFORM : "Universal", "Composite", "API"], Database);
	$.log(`âš  Settings.Switch: ${Settings?.Switch}`, "");
	switch (Settings.Switch) {
		case true:
		default:
			// è·å–å­—å¹•ç±»å‹ä¸è¯­è¨€
			const Type = url.searchParams?.get("subtype") ?? Settings.Type, Languages = [url.searchParams?.get("lang")?.toUpperCase?.() ?? Settings.Languages[0], (url.searchParams?.get("tlang") ?? Caches?.tlang)?.toUpperCase?.() ?? Settings.Languages[1]];
			$.log(`âš  Type: ${Type}, Languages: ${Languages}`, "");
			// åˆ›å»ºå­—å¹•è¯·æ±‚é˜Ÿåˆ—
			let requests = [];
			// å¤„ç†ç±»å‹
			switch (Type) {
				case "Official":
					$.log(`âš  å®˜æ–¹å­—å¹•`, "");
					switch (PLATFORM) {
						default:
							// è·å–å­—å¹•æ–‡ä»¶åœ°å€vttç¼“å­˜ï¼ˆmapï¼‰
							const { subtitlesPlaylistURL } = getSubtitlesCache($request.url, Caches.Playlists.Subtitle, Languages);
							// è·å–å­—å¹•æ’­æ”¾åˆ—è¡¨m3u8ç¼“å­˜ï¼ˆmapï¼‰
							const { masterPlaylistURL, subtitlesPlaylistIndex } = getPlaylistCache(subtitlesPlaylistURL, Caches.Playlists.Master, Languages);
							// è·å–å­—å¹•æ–‡ä»¶åœ°å€vttç¼“å­˜ï¼ˆmapï¼‰
							const { subtitlesURIArray0, subtitlesURIArray1 } = getSubtitlesArray(masterPlaylistURL, subtitlesPlaylistIndex, Caches.Playlists.Master, Caches.Playlists.Subtitle, Languages);
							// è·å–å®˜æ–¹å­—å¹•è¯·æ±‚
							if (subtitlesURIArray1.length) {
								$.log(`ğŸš§ subtitlesURIArray1.length: ${subtitlesURIArray1.length}`, "");
								// è·å–å­—å¹•æ–‡ä»¶å
								let fileName = PATHs?.[PATHs?.length - 1] ?? getSubtitlesFileName($request.url, PLATFORM);
								$.log(`ğŸš§ fileName: ${fileName}`, "")
								// æ„é€ è¯·æ±‚é˜Ÿåˆ—
								requests = constructSubtitlesQueue($request, fileName, subtitlesURIArray0, subtitlesURIArray1);
							};
							break;
						case "YouTube":
							$.log(`âš  YouTube`, "");
							switch (url.searchParams.get("tlang")) {
								case undefined:
									$.log(`âš  æœªé€‰æ‹©ç¿»è¯‘è¯­è¨€ï¼Œè·³è¿‡`, "");
									break;
								default:
									$.log(`âš  å·²é€‰æ‹©ç¿»è¯‘è¯­è¨€`, "");
									// è®¾ç½®å‚æ•°
									// Settings.Offset = 0;
									Settings.Tolerance = 100;
									Settings.Position = (Settings.Position === "Reverse") ? "Forward" : "Reverse"; // é“¾æ¥ä¸»å­—å¹•ä¸ºç¿»è¯‘å­—å¹•ï¼Œå‰¯å­—å¹•ä¸ºåŸå­—å¹•ï¼Œæ‰€ä»¥éœ€è¦ç¿»è½¬ä¸€ä¸‹
									switch (Settings.ShowOnly) {
										case true:
											$.log(`âš  ä»…æ˜¾ç¤ºç¿»è¯‘åå­—å¹•ï¼Œè·³è¿‡`, "");
											break;
										case false:
										default:
											$.log(`âš  ç”ŸæˆåŒè¯­å­—å¹•`, "");
											// è·å–å­—å¹•
											url.searchParams.set("lang", Caches.Playlists.Subtitle.get(url.searchParams.get("v")) || url.searchParams.get("lang")); // ä¸»è¯­è¨€
											url.searchParams.delete("tlang") // åŸå­—å¹•
											let request = {
												"url": url.toString(),
												"headers": $request.headers
											};
											requests.push(request);
											break;
									};
							};
							break;
						case "Netflix":
							$.log(`âš  Netflix`, "");
							break;
						case "Bilibili":
							$.log(`âš  Bilibili`, "");
							break;
					};
					break;
				case "Translate":
				default:
					$.log(`âš  ç¿»è¯‘å­—å¹•`, "");
					break;
				case "External":
					$.log(`âš  å¤–æŒ‚å­—å¹•`, "");
					switch (Settings.SubVendor) {
						case "URL":
							let request = {
								"url": Settings.URL,
								"headers": {
									"Accept": "*/*",
									"User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.1 Mobile/15E148 Safari/604.1"
								}
							};
							requests.push(request);
							break;
					};
					break;
			};
			// æ ¼å¼åˆ¤æ–­
			switch (FORMAT) {
				case undefined: // è§†ä¸ºæ— body
					break;
				case "application/x-www-form-urlencoded":
				case "text/plain":
				default:
					break;
				case "application/x-mpegURL":
				case "application/x-mpegurl":
				case "application/vnd.apple.mpegurl":
				case "audio/mpegurl":
					break;
				case "text/xml":
				case "text/html":
				case "text/plist":
				case "application/xml":
				case "application/plist":
				case "application/x-plist":
					body = XML.parse($response.body);
					await Promise.all(requests.map(async request => {
						let officialSubtitle = await $.fetch(request).then(response => XML.parse(response.body));
						body = new Composite(Settings).timedText(body, officialSubtitle, url.searchParams.get("kind"));
					}));
					$response.body = XML.stringify(body);
					break;
				case "text/vtt":
				case "application/vtt":
					body = VTT.parse($response.body);
					await Promise.all(requests.map(async request => {
						let officialSubtitle = await $.fetch(request).then(response => VTT.parse(response.body));
						body = new Composite(Settings).webVTT(body, officialSubtitle);
					}));
					$response.body = VTT.stringify(body);
					break;
				case "text/json":
				case "application/json":
					body = JSON.parse($response.body ?? "{}");
					await Promise.all(requests.map(async request => {
						let officialSubtitle = await $.fetch(request).then(response => JSON.parse(response.body));
						body = new Composite(Settings).JSON(body, officialSubtitle, url.searchParams.get("kind"));
					}));
					$response.body = JSON.stringify(body);
					break;
				case "application/protobuf":
				case "application/x-protobuf":
				case "application/vnd.google.protobuf":
				case "application/grpc":
				case "application/grpc+proto":
				case "application/octet-stream":
					break;
			};
			break;
		case false:
			break;
	};
})()
	.catch((e) => $.logErr(e))
	.finally(() => $.done($response))

/***************** Function *****************/
/**
 * Get Playlist Cache
 * @author VirgilClyne
 * @param {String} url - Request URL / Master Playlist URL
 * @param {Map} cache - Playlist Cache
 * @param {Array} languages - Languages
 * @return {Promise<Object>} { masterPlaylistURL, subtitlesPlaylist, subtitlesPlaylistIndex }
 */
function getPlaylistCache(url, cache, languages) {
	$.log(`â˜‘ï¸ getPlaylistCache`, "");
	let masterPlaylistURL = "";
	let subtitlesPlaylist = {};
	let subtitlesPlaylistIndex = 0;
	cache?.forEach((Value, Key) => {
		languages?.forEach(language => {
			if (Array.isArray(Value?.[language])) {
				let Array = Value?.[language];
				if (Array?.some((Object, Index) => {
					if (url.includes(Object?.URI || Object?.OPTION?.URI || null)) {
						subtitlesPlaylistIndex = Index;
						$.log(`ğŸš§ getPlaylistCache`, `subtitlesPlaylistIndex: ${subtitlesPlaylistIndex}`, "");
						return true;
					} else return false;
				})) {
					masterPlaylistURL = Key;
					subtitlesPlaylist = Value;
					//$.log(`ğŸš§ getPlaylistCache`, `masterPlaylistURL: ${masterPlaylistURL}`, `subtitlesPlaylist: ${JSON.stringify(subtitlesPlaylist)}`, "");
				};
			};
		});
	});
	$.log(`âœ… getPlaylistCache`, `masterPlaylistURL: ${JSON.stringify(masterPlaylistURL)}`, "");
	return { masterPlaylistURL, subtitlesPlaylist, subtitlesPlaylistIndex };
};

/**
 * Get Subtitles Cache
 * @author VirgilClyne
 * @param {String} url - Request URL / Subtitles URL
 * @param {Map} cache - Subtitles Cache
 * @param {Array} languages - Languages
 * @return {Promise<Object>} { subtitlesPlaylistURL, subtitles, subtitlesIndex }
 */
function getSubtitlesCache(url, cache, languages) {
	$.log(`â˜‘ï¸ getSubtitlesCache`, "");
	let subtitlesPlaylistURL = "";
	let subtitles = [];
	let subtitlesIndex = 0;
	cache?.forEach((Value, Key) => {
		if (Array.isArray(Value)) {
			let Array = Value;
			if (Array?.some((String, Index) => {
				if (url.includes(String || null)) {
					subtitlesIndex = Index;
					$.log(`ğŸš§ getSubtitlesCache`, `subtitlesIndex: ${subtitlesIndex}`, "");
					return true;
				} else return false;
			})) {
				subtitlesPlaylistURL = Key;
				subtitles = Value;
				//$.log(`ğŸš§ getSubtitlesCache, subtitlesPlaylistURL: ${subtitlesPlaylistURL}`, "");
			};
		};
	});
	$.log(`âœ… getSubtitlesCache, subtitlesPlaylistURL: ${subtitlesPlaylistURL}`, "");
	return { subtitlesPlaylistURL, subtitles, subtitlesIndex };
};

/**
 * Get Subtitles Array
 * @author VirgilClyne
 * @param {String} url - Request URL / Master Playlist URL
 * @param {Number} index - Subtitles Playlist Index
 * @param {Map} playlistsCache - Playlists Cache
 * @param {Map} subtitlesCache - Subtitles Cache
 * @param {Array} languages - Languages
 * @return {Promise<Object>} { subtitlesURIArray0, subtitlesURIArray1 }
 */
function getSubtitlesArray(url, index, playlistsCache, subtitlesCache, languages) {
	$.log(`â˜‘ï¸ getSubtitlesArray`, "");
	const subtitlesPlaylistValue = playlistsCache?.get(url) || {};
	let subtitlesPlaylistURL0 = subtitlesPlaylistValue?.[languages[0]]?.[index]?.URL || subtitlesPlaylistValue?.[languages[0]]?.[0]?.URL;
	let subtitlesPlaylistURL1 = subtitlesPlaylistValue?.[languages[1]]?.[index]?.URL || subtitlesPlaylistValue?.[languages[1]]?.[0]?.URL;
	$.log(`ğŸš§ getSubtitlesArray`, `subtitlesPlaylistURL0: ${subtitlesPlaylistURL0}, subtitlesPlaylistURL1: ${subtitlesPlaylistURL1}`, "");
	// æŸ¥æ‰¾å­—å¹•æ–‡ä»¶åœ°å€vttç¼“å­˜ï¼ˆmapï¼‰
	let subtitlesURIArray0 = subtitlesCache.get(subtitlesPlaylistURL0) || [];
	let subtitlesURIArray1 = subtitlesCache.get(subtitlesPlaylistURL1) || [];
	//$.log(`ğŸš§ getSubtitlesArray`, `subtitlesURIArray0: ${JSON.stringify(subtitlesURIArray0)}, subtitlesURIArray1: ${JSON.stringify(subtitlesURIArray1)}`, "");
	$.log(`âœ… getSubtitlesArray`, "");
	return { subtitlesURIArray0, subtitlesURIArray1 };
};

/**
 * Get Subtitles FileName
 * @author VirgilClyne
 * @param {String} url - Request URL / Subtitles URL
 * @param {String} platform - Platform Name
 * @return {String<*>} fileName
 */
function getSubtitlesFileName(url, platform) {
	$.log(`â˜‘ï¸ Get Subtitles FileName`, `url: ${url}`, "");
	let fileName = undefined;
	switch (platform) {
		case "Apple":
			fileName = request.url.match(/.+_(subtitles(_V\d)?-\d+\.webvtt)\?(.*)subtype=/)[1]; // Apple ç‰‡æ®µåˆ†å‹åºå·ä¸åŒ
			break;
		case "Disney+":
			fileName = request.url.match(/([^\/]+\.vtt)\?(.*)subtype=/)[1]; // Disney+ ç‰‡æ®µåç§°ç›¸åŒ
			break;
		case "Hulu":
			fileName = request.url.match(/.+_(SEGMENT\d+_.+\.vtt)\?(.*)subtype=/)[1]; // Hulu ç‰‡æ®µåˆ†å‹åºå·ç›¸åŒ
			break;
		case "PrimeVideo":
		case "HBOMax":
		default:
			fileName = null; // Amazon Prime Video HBO_Maxä¸æ‹†åˆ†å­—å¹•ç‰‡æ®µ
			break;
	};
	$.log(`âœ… Get Subtitles FileName`, `fileName: ${fileName}`, "");
	return fileName;
};

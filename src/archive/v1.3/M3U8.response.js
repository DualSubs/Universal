import _ from '../../ENV/Lodash.mjs'
import $Storage from '../../ENV/$Storage.mjs'
import ENV from "../../ENV/ENV.mjs";
import URI from "../../URI/URI.mjs";
import M3U8 from "../../EXTM3U/EXTM3U.mjs";

import Database from "../../database/index.mjs";
import detectPlatform from "../../function/detectPlatform.mjs";
import setENV from "../../function/setENV.mjs";
import isStandard from "../../function/isStandard.mjs";
import detectPlaylist from "../../function/detectPlaylist.mjs";
import setCache from "../../function/setCache.mjs";
import setOption from "../../function/setOption.mjs";

const $ = new ENV("üçøÔ∏è DualSubs: üé¶ Universal v1.0.1(2) M3U8.response");

/***************** Processing *****************/
// Ëß£ÊûÑURL
const URL = URI.parse($request.url);
$.log(`‚ö† URL: ${JSON.stringify(URL)}`, "");
// Ëé∑ÂèñËøûÊé•ÂèÇÊï∞
const METHOD = $request.method, HOST = URL.host, PATH = URL.path, PATHs = URL.paths;
$.log(`‚ö† METHOD: ${METHOD}`, "");
// Ëß£ÊûêÊ†ºÂºè
const FORMAT = ($response.headers?.["Content-Type"] ?? $response.headers?.["content-type"])?.split(";")?.[0];
$.log(`‚ö† FORMAT: ${FORMAT}`, "");
(async () => {
	// Ëé∑ÂèñÂπ≥Âè∞
	const PLATFORM = detectPlatform($request.url);
	$.log(`‚ö† PLATFORM: ${PLATFORM}`, "");
	// ËØªÂèñËÆæÁΩÆ
	const { Settings, Caches, Configs } = setENV("DualSubs", [(["YouTube", "Netflix", "BiliBili", "Spotify"].includes(PLATFORM)) ? PLATFORM : "Universal", "Composite"], Database);
	$.log(`‚ö† Settings.Switch: ${Settings?.Switch}`, "");
	switch (Settings.Switch) {
		case true:
		default:
			// Ëé∑ÂèñÂ≠óÂπïÁ±ªÂûã‰∏éËØ≠Ë®Ä
			const Type = URL.query?.subtype ?? Settings.Type, Languages = [URL.query?.lang?.toUpperCase?.() ?? Settings.Languages[0], (URL.query?.tlang ?? Caches?.tlang)?.toUpperCase?.() ?? Settings.Languages[1]];
			$.log(`‚ö† Type: ${Type}, Languages: ${Languages}`, "");
			// ÂÖºÂÆπÊÄßÂà§Êñ≠
			const { standard: STANDARD, device: DEVICE } = isStandard(URL, $request.headers, PLATFORM);
			// ÂàõÂª∫Á©∫Êï∞ÊçÆ
			let body = {};
			// Ê†ºÂºèÂà§Êñ≠
			switch (FORMAT) {
				case undefined: // ËßÜ‰∏∫Êó†body
					break;
				case "application/x-www-form-urlencoded":
				case "text/plain":
				default:
					break;
				case "application/x-mpegURL":
				case "application/x-mpegurl":
				case "application/vnd.apple.mpegurl":
				case "audio/mpegurl":
					// Â∫èÂàóÂåñM3U8
					body = M3U8.parse($response.body);
					//$.log(`üöß M3U8.parse($response.body): ${JSON.stringify(body)}`, "");
					// Ëé∑ÂèñÊí≠ÊîæÂàóË°®Á±ªÂûã
					switch (detectPlaylist(body)) {
						case "Multivariant Playlist":
							// ËØªÂèñÂ∑≤Â≠òÊï∞ÊçÆ
							let playlistCache = Caches.Playlists.Master.get($request.url) || {};
							// Ëé∑ÂèñÁâπÂÆöËØ≠Ë®ÄÁöÑÂ≠óÂπï
							playlistCache[Languages[0]] = getAttrList($request.url, body, "SUBTITLES", Configs.Languages[Languages[0]]);
							playlistCache[Languages[1]] = getAttrList($request.url, body, "SUBTITLES", Configs.Languages[Languages[1]]);
							// ÂÜôÂÖ•Êï∞ÊçÆ
							Caches.Playlists.Master.set($request.url, playlistCache);
							// Ê†ºÂºèÂåñÁºìÂ≠ò
							Caches.Playlists.Master = setCache(Caches.Playlists.Master, Settings.CacheSize);
							// ÂÜôÂÖ•ÊåÅ‰πÖÂåñÂÇ®Â≠ò
							$Storage.setItem(`@DualSubs.${"Composite"}.Caches.Playlists.Master`, Caches.Playlists.Master);
							// ÂÜôÂÖ•ÈÄâÈ°π
							body = setAttrList(body, playlistCache, Settings.Types, Languages, PLATFORM, STANDARD, DEVICE);
							break;
						case "Media Playlist":
							// Â§ÑÁêÜÁ±ªÂûã
							switch (Type) {
								case "Official":
									$.log(`‚ö† ÂÆòÊñπÂ≠óÂπï`, "");
									// Ëé∑ÂèñÂ≠óÂπïÊí≠ÊîæÂàóË°®m3u8ÁºìÂ≠òÔºàmapÔºâ
									const { subtitlesPlaylist, subtitlesPlaylistIndex } = getPlaylistCache($request.url, Caches.Playlists.Master, Languages[0]) ?? getPlaylistCache($request.url, Caches.Playlists.Master, Languages[1]);
									// ÂÜôÂÖ•Â≠óÂπïÊñá‰ª∂Âú∞ÂùÄvttÁºìÂ≠òÔºàmapÔºâ
									Caches.Playlists.Subtitle = await setSubtitlesCache(Caches.Playlists.Subtitle, subtitlesPlaylist, Languages[0], subtitlesPlaylistIndex, PLATFORM);
									Caches.Playlists.Subtitle = await setSubtitlesCache(Caches.Playlists.Subtitle, subtitlesPlaylist, Languages[1], subtitlesPlaylistIndex, PLATFORM);
									// Ê†ºÂºèÂåñÁºìÂ≠ò
									Caches.Playlists.Subtitle = setCache(Caches?.Playlists.Subtitle, Settings.CacheSize);
									// ÂÜôÂÖ•ÁºìÂ≠ò
									$Storage.setItem(`@DualSubs.${"Composite"}.Caches.Playlists.Subtitle`, Caches.Playlists.Subtitle);
									break;
								case "Translate":
								default:
									$.log(`‚ö† ÁøªËØëÂ≠óÂπï`, "");
									break;
								case "External":
									$.log(`‚ö† Â§ñÊåÇÂ≠óÂπï`, "");
									break;
							};
							// WebVTT.m3u8Âä†ÂèÇÊï∞
							body = body.map((item, i) => {
								if (/^.+\.((web)?vtt|ttml2?|xml|smi)(\?.+)?$/.test(item?.URI)) {
									const symbol = (item.URI.includes("?")) ? "&" : "?";
									if (!/empty|blank|default/.test(item.URI)) {
										if (URL.query?.lang) item.URI += `${symbol}subtype=${Type}&lang=${URL.query.lang}`;
										else item.URI += `${symbol}subtype=${Type}`;
									};
									if (item.TAG === "#EXT-X-BYTERANGE") body[i - 1].URI = item.URI; // Âà†Èô§BYTERANGE
									else return item;
								} else return item;
							});
							break;
					};
					// Â≠óÁ¨¶‰∏≤M3U8
					$response.body = M3U8.stringify(body);
					break;
				case "text/xml":
				case "text/html":
				case "text/plist":
				case "application/xml":
				case "application/plist":
				case "application/x-plist":
					break;
				case "text/vtt":
				case "application/vtt":
					break;
				case "text/json":
				case "application/json":
					break;
				case "application/protobuf":
				case "application/x-protobuf":
				case "application/vnd.google.protobuf":
				case "application/grpc":
				case "application/grpc+proto":
				case "application/octet-stream":
					break;
			};
			break;
		case false:
			break;
	};
})()
	.catch((e) => $.logErr(e))
	.finally(() => $.done($response))

/***************** Function *****************/
/**
 * Get Attribute List
 * @author VirgilClyne
 * @param {String} url - Request URL
 * @param {Object} m3u8 - Parsed M3U8
 * @param {String} type - Content Type
 * @param {Array} langCodes - Language Codes Array
 * @return {Array} datas
 */
function getAttrList(url = "", m3u8 = {}, type = "", langCodes = []) {
	$.log(`‚òëÔ∏è Get Attribute List`, `langCodes: ${langCodes}`, "");
	let attrList = m3u8
		.filter(item => item?.TAG === "#EXT-X-MEDIA") // ËøáÊª§Ê†áÁ≠æ
		.filter(item => item?.OPTION?.TYPE === type) // ËøáÊª§Á±ªÂûã
		.filter(item => item?.OPTION?.FORCED !== "YES"); // ËøáÊª§Âº∫Âà∂ÂÜÖÂÆπ
	//$.log(`üöß attrList: ${JSON.stringify(attrList)}`, "");
	let matchList = [];
	//Êü•ËØ¢ÊòØÂê¶ÊúâÁ¨¶ÂêàËØ≠Ë®ÄÁöÑÂÜÖÂÆπ
	for (let langcode of langCodes) {
		$.log(`üöß Get Attribute List`, "for (let langcode of langcodes)", `langcode: ${langcode}`, "");
		matchList = attrList.filter(item => item?.OPTION?.LANGUAGE?.toLowerCase() === langcode?.toLowerCase());
		if (matchList.length !== 0) break;
	};
	matchList = matchList.map(data => {
		data.URL = aPath(url, data?.OPTION?.URI ?? null);
		return data;
	})
	$.log(`‚úÖ Get Attribute List`, `matchList: ${JSON.stringify(matchList)}`, "");
	return matchList;
};

/**
 * Set Attribute List
 * @author VirgilClyne
 * @param {String} platform - Platform
 * @param {Object} m3u8 - Parsed m3u8
 * @param {Array} playlists1 - Primary (Source) Languages Playlists
 * @param {Array} playlists2 - Second (Target) Languages Playlists
 * @param {Array} types - Types
 * @param {Array} languages - Languages
 * @param {Boolean} Standard - Standard
 * @return {Object} m3u8
 */
function setAttrList(m3u8 = {}, playlists = {}, types = [], languages = [], platform = "", standard = true, device = "iPhone") {
	types = (standard == true) ? types : [types.at(-1)];
	const playlists1 = playlists?.[languages?.[0]];
	const playlists2 = playlists?.[languages?.[1]];
	$.log(`‚òëÔ∏è Set Attribute List`, `types: ${types}`, "");
	playlists1?.forEach(playlist1 => {
		const index1 = m3u8.findIndex(item => item?.OPTION?.URI === playlist1.OPTION.URI); // ‰∏ªËØ≠Ë®ÄÔºàÊ∫êËØ≠Ë®ÄÔºâÂ≠óÂπï‰ΩçÁΩÆ
		types.forEach(type => {
			$.log(`üöß Set Attribute List, type: ${type}`, "");
			let option = {};
			switch (type) {
				case "Official":
					playlists2?.forEach(playlist2 => {
						if (playlist1?.OPTION?.["GROUP-ID"] === playlist2?.OPTION?.["GROUP-ID"]) {
							switch (platform) { // ÂÖºÂÆπÊÄß‰øÆÊ≠£
								case "Apple":
									if (playlist1?.OPTION.CHARACTERISTICS == playlist2?.OPTION.CHARACTERISTICS) {  // Âè™ÁîüÊàêÂ±ûÊÄßÁõ∏Âêå
										option = setOption(playlist1, playlist2, type, platform, standard, device);
										option.OPTION.URI += `&lang=${languages[0]}`;
									};
									break;
								default:
									option = setOption(playlist1, playlist2, type, platform, standard, device);
									option.OPTION.URI += `&lang=${languages[0]}`;
									break;
							};
						};
					});
					break;
				case "Translate":
				case "External":
					const playlist2 = {
						"OPTION": {
							"TYPE": "SUBTITLES",
							"NAME": playlists2?.[0]?.OPTION?.NAME ?? languages[1].toLowerCase(),
							"LANGUAGE": playlists2?.[0]?.OPTION?.LANGUAGE ?? languages[1].toLowerCase(),
						}
					};
					option = setOption(playlist1, playlist2, type, platform, standard, device);
					option.OPTION.URI += `&lang=${playlist1?.OPTION?.LANGUAGE?.toUpperCase()}`;
					break;
			};
			if (Object.keys(option).length !== 0) {
				if (standard) m3u8.splice(index1 + 1, 0, option)
				else m3u8.splice(index1, 1, option);
			};
		});
	});
	//$.log(`‚úÖ Set Attribute List`, `m3u8: ${JSON.stringify(m3u8)}`, "");
	$.log(`‚úÖ Set Attribute List`, "");
	return m3u8;
};

/**
 * Get Playlist Cache
 * @author VirgilClyne
 * @param {String} url - Request URL / Master Playlist URL
 * @param {Map} cache - Playlist Cache
 * @param {String} language - Language
 * @return {Promise<Object>} { masterPlaylistURL, subtitlesPlaylist, subtitlesPlaylistIndex }
 */
function getPlaylistCache(url, cache, language) {
	$.log(`‚òëÔ∏è getPlaylistCache, language: ${language}`, "");
	let masterPlaylistURL = "";
	let subtitlesPlaylist = {};
	let subtitlesPlaylistIndex = 0;
	cache?.forEach((Value, Key) => {
		if (Array.isArray(Value?.[language])) {
			let Array = Value?.[language];
			if (Array?.some((Object, Index) => {
				if (url.includes(Object?.URI ?? Object?.OPTION?.URI ?? null)) {
					subtitlesPlaylistIndex = Index;
					$.log(`üöß getPlaylistCache`, `subtitlesPlaylistIndex: ${subtitlesPlaylistIndex}`, "");
					return true;
				} else return false;
			})) {
				masterPlaylistURL = Key;
				subtitlesPlaylist = Value;
			};
		};
	});
	$.log(`‚úÖ getPlaylistCache`, `masterPlaylistURL: ${JSON.stringify(masterPlaylistURL)}`, "");
	return { masterPlaylistURL, subtitlesPlaylist, subtitlesPlaylistIndex };
};

/**
 * Set Subtitles Cache
 * @author VirgilClyne
 * @param {Map} cache - Subtitles Cache
 * @param {Object} playlist - Subtitles Playlist Cache
 * @param {Array} language - Language
 * @param {Number} index - Subtitles Playlist Index
 * @param {String} platform - Steaming Media Platform
 * @return {Promise<Object>} { masterPlaylistURL, subtitlesPlaylist, subtitlesPlaylistIndex }
 */
async function setSubtitlesCache(cache, playlist, language, index = 0, platform = "Universal") {
	$.log(`‚òëÔ∏è setSubtitlesCache, language: ${language}, index: ${index}`, "");
	await Promise.all(playlist?.[language]?.map(async (val, ind, arr) => {
		if ((arr[index] && (ind === index)) || (!arr[index])) {
			// Êü•ÊâæÂ≠óÂπïÊñá‰ª∂Âú∞ÂùÄvttÁºìÂ≠òÔºàmapÔºâ
			let subtitlesURLarray = cache.get(val.URL) ?? [];
			// Ëé∑ÂèñÂ≠óÂπïÊñá‰ª∂Âú∞ÂùÄvtt/ttmlÁºìÂ≠òÔºàÊåâËØ≠Ë®ÄÔºâ
			if (subtitlesURLarray.length === 0) subtitlesURLarray = await getSubtitles(val?.URL, $request.headers, platform);
			// ÂÜôÂÖ•Â≠óÂπïÊñá‰ª∂Âú∞ÂùÄvtt/ttmlÁºìÂ≠òÂà∞map
			if (subtitlesURLarray.length !== 0) cache = cache.set(val.URL, subtitlesURLarray);
			$.log(`‚úÖ setSubtitlesCache`, `val?.URL: ${val?.URL}`, "");
		};
	}));
	return cache;
};

/**
 * Get Subtitle *.vtt URLs
 * @author VirgilClyne
 * @param {String} url - VTT URL
 * @param {String} headers - Request Headers
 * @param {String} platform - Steaming Media Platform
 * @return {Promise<*>}
 */
async function getSubtitles(url, headers, platform) {
	$.log(`‚òëÔ∏è Get Subtitle *.vtt *.ttml URLs`, "");
	let subtitles = await $.fetch(url, { headers: headers }).then((response, error) => {
		let subtitlePlayList = M3U8.parse(response.body);
		return subtitlePlayList
			.filter(({ URI }) => (/^.+\.((web)?vtt|ttml2?|xml|smi)(\?.+)?$/.test(URI)))
			.filter(({ URI }) => !URI.includes("empty"))
			.filter(({ URI }) => !URI.includes("blank"))
			.filter(({ URI }) => !URI.includes("default"))
			.map(({ URI }) => aPath(url, URI));
	});
	switch (platform) {
		case "Disney+":
			if (subtitles.some(item => /\/.+-MAIN\//.test(item))) subtitles = subtitles.filter(item => /\/.+-MAIN\//.test(item))
			break;
		case "PrimeVideo":
			if (subtitles.some(item => /\/aiv-prod-timedtext\//.test(item))) subtitles = subtitles.filter(item => /\/aiv-prod-timedtext\//.test(item));
			subtitles = subtitles.filter((item, index, array) => {
				// ÂΩìÂâçÂÖÉÁ¥†ÔºåÂú®ÂéüÂßãÊï∞ÁªÑ‰∏≠ÁöÑÁ¨¨‰∏Ä‰∏™Á¥¢Âºï==ÂΩìÂâçÁ¥¢ÂºïÂÄºÔºåÂê¶ÂàôËøîÂõûÂΩìÂâçÂÖÉÁ¥†
				return array.indexOf(item, 0) === index;
			}); // Êï∞ÁªÑÂéªÈáç
			break;
		default:
			break;
	};
	$.log(`‚úÖ Get Subtitle *.vtt *.ttml URLs, subtitles: ${subtitles}`, "");
	return subtitles;
};

// Get Absolute Path
function aPath(aURL = "", URL = "") { return (/^https?:\/\//i.test(URL)) ? URL : aURL.match(/^(https?:\/\/(?:[^?]+)\/)/i)?.[0] + URL };
